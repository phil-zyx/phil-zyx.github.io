[{"content":" é¢˜ç›®ï¼šå¾ªç¯æŒ‰åºæ‰“å°\u0026quot;dog\u0026quot;ã€\u0026ldquo;cat\u0026rdquo;ã€fish\u0026quot;ï¼Œåˆ†åˆ«ä½¿ç”¨ä¸‰ä¸ª goroutine.\n æ‹¿åˆ°é¢˜ç›®ï¼Œæ„Ÿè§‰ç®€å•åˆä¸ç®€å•çš„æ ·å­ï¼Œå…ˆåŠ¨æ‰‹å†™ä¸€ä¸ªæœ€ç®€å•çš„æ‰“å°ï¼š\nfunc main() { times := 100 go func() { for i := 0; i\u0026lt;times; i++ { println(\u0026#34;dog\u0026#34;) println(\u0026#34;cat\u0026#34;) println(\u0026#34;fish\u0026#34;) } }() time.Sleep(100 * 1000) // è¿™æ—¶é—´æˆ‘èƒ½ç®—å‡ºæ¥ä¹ˆï¼Œé‚£ç”¨ channel æ¥æ¥æ”¶å§ } æ”¹è¿›ä¸€ä¸‹è¿™è®©äººæ— æ³•é¢„ä¼°çš„ç­‰å¾…æ—¶é—´ï¼šä½¿ç”¨ channelï¼Œåœ¨ goroutine æ‰§è¡Œå®Œä¹‹åé€šçŸ¥ä¸»ç¨‹åºï¼Œå·©å›ºä¾ç¨€ gorutine å’Œ channel çš„åŸºç¡€çŸ¥è¯†ï¼š\n gorutine æ˜¯å¹¶å‘æ ¸å¿ƒï¼Œmain å‡½æ•°ä¹Ÿæ˜¯ä¸€ä¸ª gorutine go func() {}() åŒ¿åå‡½æ•°è¦æ³¨æ„å‚æ•°ä¼ å…¥ channel é€šè¿‡ make åˆ›å»ºï¼Œmake(chan typ) éœ€è¦å£°æ˜å¥½ç±»å‹ channel é€šè¿‡ \u0026lt;-ch ch \u0026lt;- data æ¥æ¥æ”¶å’Œå‘é€ä¿¡æ¯ channel make(ch, int, 1 è¡¨ç¤ºè¯¥ ch æ˜¯ä¸€ä¸ªæœ‰1ä¸ªæ•°æ®ç¼“å†²çš„ chanï¼Œå³åœ¨æ²¡æœ‰æ¥æ”¶æ•°æ®çš„æƒ…å†µä¸‹ï¼Œç¬¬äºŒæ¡æ•°æ®å‘é€ä¹‹åæ‰ä¼šé˜»å¡ func (ch chan \u0026lt;- int) å£°æ˜ ch æ˜¯ä¸€ä¸ªå•å‘ channel closeåçš„ chan ä¾ç„¶å¯ä»¥æ¥æ”¶ç¼“å†²é€šé“çš„æ•°æ®ï¼Œä½†ä¸å¯å‘é€æ•°æ® select {case \u0026lt;- ch: xx} å¤„ç†ä¸åŒæ¶ˆæ¯  func main() { waitCh := make(chan struct{}, 1) times := 100 go func() { for i := 0; i \u0026lt; times; i++ { println(\u0026#34;dog\u0026#34;) println(\u0026#34;cat\u0026#34;) println(\u0026#34;fish\u0026#34;) } waitCh \u0026lt;- struct{}{} }() \u0026lt;-waitCh } waitCh å¬èµ·æ¥æ€ä¹ˆè¿™ä¹ˆç†Ÿæ‚‰å‘¢ï¼Ÿgo æœ¬èº«åœ¨é¢å¯¹è¿™äº›æƒ…å†µå·²ç»å®ç°äº†ä¸€ä¸ªå·¥å…·ç±»ï¼Œsync åŒ…ä¸­æä¾›çš„åŸºç¡€åŸè¯­ï¼š waitGroup ã€‚å·©å›ºä¸€ä¸‹ï¼š\n å®˜æ–¹æè¿°ï¼šä¸€ä¸ª WaitGroup å¯¹è±¡å¯ä»¥ç­‰å¾…ä¸€ç»„åç¨‹ç»“æŸ æˆ‘ä»¬å¯ä»¥é€šè¿‡ sync.WaitGroup å°†åŸæœ¬é¡ºåºæ‰§è¡Œçš„ä»£ç åœ¨å¤šä¸ª Goroutine ä¸­å¹¶å‘æ‰§è¡Œï¼ŒåŠ å¿«ç¨‹åºå¤„ç†çš„é€Ÿåº¦ã€‚ è¯¥ç±»æš´éœ²ä¸‰ä¸ªæ¥å£ï¼šadd wait done åºŸè¯åˆ«è¯´ï¼Œshow me the code ğŸ™‚  func main() { wg := sync.WaitGroup{} times := 100 wg.Add(1) // åç¨‹æ•° \tgo func() { for i := 0; i \u0026lt; times; i++ { println(\u0026#34;dog\u0026#34;) println(\u0026#34;cat\u0026#34;) println(\u0026#34;fish\u0026#34;) } wg.Done() // åç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œä¸€èˆ¬å¤æ‚ä¸šåŠ¡ä¼šæœ‰å®¹é”™ï¼Œç¡®ä¿æ‰§è¡Œï¼š defer wg.Done() \t}() wg.Wait() } å®ç°ä¸‰ä¸ªç›´æ¥æ‰“å°çš„ goroutine å¿…ç„¶ä¸èƒ½ä¿è¯æœ‰åºï¼Œé‚£å°±å¿…é¡»åœ¨ goroutine é—´é€šä¿¡ï¼Œcha -\u0026gt; chb -\u0026gt; chc-\u0026gt;cha å¾ªç¯è§¦å‘åˆ™å¯ä»¥å®ç°è¯¥åŠŸèƒ½ã€‚\nfunc main() { wg := sync.WaitGroup{} wg.Add(3) dogCh := make(chan struct{}, 1) catCh := make(chan struct{}, 1) fishCh := make(chan struct{}, 1) times := 10 dogCounter, catCounter, fishCounter := 0, 0, 0 go PrintTheVal(dogCh, catCh, dogCounter, times, \u0026amp;wg, \u0026#34;dog\u0026#34;) // \u0026amp;wg éœ€è¦å–åœ°å€ \tgo PrintTheVal(catCh, fishCh, catCounter, times, \u0026amp;wg, \u0026#34;cat\u0026#34;) go PrintTheVal(fishCh, dogCh, fishCounter, times, \u0026amp;wg, \u0026#34;fish\u0026#34;) dogCh \u0026lt;- struct{}{} wg.Wait() } func PrintTheVal(selfCh, toCh chan struct{}, counter, max int, wg *sync.WaitGroup, val string) { for { \u0026lt;- selfCh toCh \u0026lt;- struct{}{} if counter \u0026gt;= max { wg.Done() return } println(val) counter++ } } æ€»ç»“  é€šè¿‡ç®€å•çš„é¢˜ç›®èƒ½å¿«é€Ÿç†è§£åŸºç¡€è¯­æ³•ï¼Œä¹Ÿèƒ½åœ¨å®ç°ç®€å•é¢˜ç›®ä¸­å‘ç°ä¸è¶³å’Œå·©å›ºåŸºç¡€ã€‚ å‘æ•£æ€ç»´ï¼šå…¶ä»–åŒæ­¥åŸè¯­çš„ä½¿ç”¨ï¼Ÿ  ","permalink":"https://Phil-zyx.github.io/posts/%E4%B8%80%E9%81%93go%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9A%84%E5%8F%8D%E6%80%9D/","summary":"é¢˜ç›®ï¼šå¾ªç¯æŒ‰åºæ‰“å°\u0026quot;dog\u0026quot;ã€\u0026ldquo;cat\u0026rdquo;ã€fish\u0026quot;ï¼Œåˆ†åˆ«ä½¿ç”¨ä¸‰ä¸ª goroutine.\n æ‹¿åˆ°é¢˜ç›®ï¼Œæ„Ÿè§‰ç®€å•åˆä¸ç®€å•çš„æ ·å­ï¼Œå…ˆåŠ¨æ‰‹å†™ä¸€ä¸ªæœ€ç®€å•çš„æ‰“å°ï¼š\nfunc main() { times := 100 go func() { for i := 0; i\u0026lt;times; i++ { println(\u0026#34;dog\u0026#34;) println(\u0026#34;cat\u0026#34;) println(\u0026#34;fish\u0026#34;) } }() time.Sleep(100 * 1000) // è¿™æ—¶é—´æˆ‘èƒ½ç®—å‡ºæ¥ä¹ˆï¼Œé‚£ç”¨ channel æ¥æ¥æ”¶å§ } æ”¹è¿›ä¸€ä¸‹è¿™è®©äººæ— æ³•é¢„ä¼°çš„ç­‰å¾…æ—¶é—´ï¼šä½¿ç”¨ channelï¼Œåœ¨ goroutine æ‰§è¡Œå®Œä¹‹åé€šçŸ¥ä¸»ç¨‹åºï¼Œå·©å›ºä¾ç¨€ gorutine å’Œ channel çš„åŸºç¡€çŸ¥è¯†ï¼š\n gorutine æ˜¯å¹¶å‘æ ¸å¿ƒï¼Œmain å‡½æ•°ä¹Ÿæ˜¯ä¸€ä¸ª gorutine go func() {}() åŒ¿åå‡½æ•°è¦æ³¨æ„å‚æ•°ä¼ å…¥ channel é€šè¿‡ make åˆ›å»ºï¼Œmake(chan typ) éœ€è¦å£°æ˜å¥½ç±»å‹ channel é€šè¿‡ \u0026lt;-ch ch \u0026lt;- data æ¥æ¥æ”¶å’Œå‘é€ä¿¡æ¯ channel make(ch, int, 1 è¡¨ç¤ºè¯¥ ch æ˜¯ä¸€ä¸ªæœ‰1ä¸ªæ•°æ®ç¼“å†²çš„ chanï¼Œå³åœ¨æ²¡æœ‰æ¥æ”¶æ•°æ®çš„æƒ…å†µä¸‹ï¼Œç¬¬äºŒæ¡æ•°æ®å‘é€ä¹‹åæ‰ä¼šé˜»å¡ func (ch chan \u0026lt;- int) å£°æ˜ ch æ˜¯ä¸€ä¸ªå•å‘ channel closeåçš„ chan ä¾ç„¶å¯ä»¥æ¥æ”¶ç¼“å†²é€šé“çš„æ•°æ®ï¼Œä½†ä¸å¯å‘é€æ•°æ® select {case \u0026lt;- ch: xx} å¤„ç†ä¸åŒæ¶ˆæ¯  func main() { waitCh := make(chan struct{}, 1) times := 100 go func() { for i := 0; i \u0026lt; times; i++ { println(\u0026#34;dog\u0026#34;) println(\u0026#34;cat\u0026#34;) println(\u0026#34;fish\u0026#34;) } waitCh \u0026lt;- struct{}{} }() \u0026lt;-waitCh } waitCh å¬èµ·æ¥æ€ä¹ˆè¿™ä¹ˆç†Ÿæ‚‰å‘¢ï¼Ÿgo æœ¬èº«åœ¨é¢å¯¹è¿™äº›æƒ…å†µå·²ç»å®ç°äº†ä¸€ä¸ªå·¥å…·ç±»ï¼Œsync åŒ…ä¸­æä¾›çš„åŸºç¡€åŸè¯­ï¼š waitGroup ã€‚å·©å›ºä¸€ä¸‹ï¼š","title":"ä¸€é“GOç¼–ç¨‹é¢˜çš„åæ€"},{"content":"2020 å³å°†è¿‡å»ï¼Œè¿™ä¸€å¹´æœ€å¤§çš„æ€»ç»“å°±æ˜¯ï¼šä»€ä¹ˆç›®æ ‡ä¹Ÿæ²¡æœ‰å®Œæˆã€‚\n","permalink":"https://Phil-zyx.github.io/posts/summary2020/","summary":"2020 å³å°†è¿‡å»ï¼Œè¿™ä¸€å¹´æœ€å¤§çš„æ€»ç»“å°±æ˜¯ï¼šä»€ä¹ˆç›®æ ‡ä¹Ÿæ²¡æœ‰å®Œæˆã€‚","title":"2020 å¹´ç»ˆæ€»ç»“"}]